---
title: "run_spiec_easi_analyse"
author: "ruben"
date: "04/03/2022"
output: html_document
---


## Librairies

```{r,message=F,warning=F}


library(data.table)
library(devtools)
library(microbiome)
library(phyloseq)
library(RColorBrewer)
library(ggpubr)
library(dplyr)
library(SpiecEasi)  
library(network)
library(intergraph)
library(ggnet)
library(igraph)
library(fantaxtic)
library(metagMisc)
library(tibble)
library(varhandle)

source(file = "functions.R")

```


## Import données

```{r,message=F,warning=F}

load(file = "study_after_QC.rda")

OTU <- otus

MAP <- map

TAX <- tax

```

## Filtre données

```{r,message=F,warning=F}

## on prend les ID en commun

common.ids <- intersect(t(colnames(OTU)), MAP$sample_id)

otu <- OTU[,common.ids]


tax <- TAX

map <- MAP %>%
  filter(sample_id %in% common.ids)


# si un patient a plusieurs échantillons, on prend celui qui aura le nombre de reads le plus élevé

map <- unique(setDT(map)[order(sample_id, -number_reads)], by = "sample_id")

nrow(map)

ncol(otu)

# tout est ok !
```


### Processing

```{r,message=F,warning=F}

# définition du nom des lignes pour map

mapp <- map %>% 
  tibble::column_to_rownames("sample_id") 

# création de l'object phyloseq

## matrices

otu <- as.matrix(otu)


## au niveau du genre on veut voir l'interaction entre les bifids et les non bifids

taxo <- tax %>%
  as.data.frame() %>%
  mutate(Genus =
           case_when(Genus == 'Bifidobacterium' ~ "Bifidobacterium", 
                     TRUE ~ "Other Genus")) %>%
  as.matrix(tax) %>%
  tax_table(.)


##

```

## Objet Phyloseq

```{r,message=F,warning=F}

otu <- otu_table(otu, taxa_are_rows = TRUE)
mapp <- sample_data(mapp)


phy <- phyloseq(otu, mapp, taxo)

#save(phy, file="phy_curated_data_after_QC.rda")

```

## Fitre et objet phyloseq

```{r,message=F,warning=F}

# que les échantillons stool

phy <- subset_samples(phy, body_site == "stool")

phy <- subset_samples(phy, age_category == "adult")

```

## Selections des otus a mettre en relation

```{r,message=F,warning=F}

## we will take the first 100 non bifid otus, most abundant in this cohort
## and all 32 bifid otus to calculate the matrix of covarience

otu_filtered <- data.frame(phy@otu_table)
  
tax_filtered <- data.frame(phy@tax_table)


```

## Subset des données

```{r,message=F,warning=F}

# en 1 : en gros 100 premiers non bifids, 32 bifid

names_otu_interet <- subset_bifid_non_bifid(100, 32, otu_filtered, tax_filtered) ## 100 most abundant non bifid taxa, and 32 all bifid

# en 2 : les 150 les plus prévalents

#names_otu_interet <- select_n_otu(150, otu_filtered)

phy <- prune_taxa(taxa_names(phy) %in% names_otu_interet, phy)

phy <- prune_samples(sample_sums(phy)>=1000, phy) # select sample with at least 1000 reads assigned to bifidobacterium

## save the phy object for differential analysis

name = "phy_deseq_analysis_bis"

if(!(name %in% list.files())) {
  
  save(phy, file = name)
  
} else {
  load(name)
  }


```

## rarefaction

```{r,message=F,warning=F}

## on normalise


# on keep les otus et tax

otu.c.w <- otu_table(phy)@.Data

tax.c <- as.data.frame(tax_table(phy)@.Data)


# rarefaction to 1000 reads
otu.c.w <- vegan::rrarefy(t(otu.c.w), 1000)

```

## Fitre et objet phyloseq

```{r,message=F,warning=F}

set.seed(1244)




net.c.w <- spiec.easi(phy,
                    method='mb',
                    lambda.min.ratio=1e-2,
                    nlambda=20,
                    pulsar.params=list(rep.num=20,
                                       ncores=12))

```

## process

```{r,message=F,warning=F,fig.height=9, fig.width=12}

## we get the weight of each association

sebeta <- symBeta(getOptBeta(net.c.w), mode='maxabs')

## affect the colnames and rownames

colnames(sebeta) <- rownames(sebeta) <- rownames(t(otu.c.w))

# vsize <- log2(apply(otu.c, 2, mean)) # add log abundance as properties of vertex/nodes.

```

## prepare data for plotting

```{r,message=F,warning=F,fig.height=9, fig.width=12}

graph <- graph.adjacency(sebeta, mode='undirected', add.rownames = TRUE, weighted = TRUE)
graph # we can see all the attributes and weights


```
## set the plot parameters

```{r,message=F,warning=F,fig.height=9, fig.width=12}

## set a different colar for negative/positive weights

E(graph)[weight > 0]$color<-"orange" #now color the edges based on their values positive is steelblue
E(graph)[weight < 0]$color<-"steelblue"  #now color the edges based on their values


###########################

name_species <- get_species(tax, V(graph)$name)
V(graph)$name <- name_species


## on ne va afficher le nom que des bifids


lien <- get.edgelist(graph)


## je vais afficher adolescentis seulement et les b liées à adolescentis (espèce commensale)

select_bact <- lien %>%
  data.frame(.) %>%
  filter(grepl('Bifidobacterium', X1))

bact_a_afficher <- unique(c(unique(as.character(select_bact$X1)), unique(as.character(select_bact$X2))))

### j'affiche que ces nom dans le network d'interaction

test <- V(graph)$name %>%
  as.data.frame(.)

names(test) <- "V1"

library(Hmisc)

test <- test %>%
  unfactor(.) %>%
  mutate(bifid = case_when(V1 %in% bact_a_afficher ~ V1
                        )) %>%
   mutate(non_bifid = case_when(V1 %nin% bact_a_afficher ~ V1
                        ))

non_bifid_species <- test$non_bifid[!is.na(test$non_bifid)]

## we will keep only edges which contains bifidobacterium species

g <- graph - non_bifid_species

#V(g)$name <- test$bifid

## we suppress vertices with no links to the bifido

g = delete.vertices(g,degree(g)<1)



```

## change different set of names

```{r,message=F,warning=F,fig.height=12, fig.width=12}

### add a label for bifid and non bifid species

pal <- brewer.pal(2,"Accent")

Group <- factor(get_bifid_species(tax, V(g)$name))

vertex.col <- pal[Group]

## change b name to be shorter

V(g)$name <- gsub("Bifidobacterium", "B.", V(g)$name)

```

## plotting

```{r,message=F,warning=F,fig.height=12, fig.width=12}


V(g)$name <- gsub("Bifidobacterium", "B.", V(g)$name)

set.seed(12)

plot(g,
     layout=layout.fruchterman.reingold(g),
     vertex.color=vertex.col , vertex.cex = 0,
     vertex.size = 3,vertex.label.color= "black", displaylabels = TRUE, boxed.labels =FALSE, vertex.label.dist=0.6)
 
legend("topleft",
       legend=levels(Group),
       fill=pal, border=NA, col="black")


```



